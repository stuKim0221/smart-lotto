package app.grapekim.smartlotto.ui.analysis;

import android.app.Dialog;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.fragment.app.DialogFragment;

import app.grapekim.smartlotto.R;
import app.grapekim.smartlotto.data.local.room.entity.GeneratedPickEntity;
import app.grapekim.smartlotto.util.LottoNumberAnalyzer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class NumberAnalysisDialog extends DialogFragment {

    private static final String TAG = "NumberAnalysisDialog";
    private static final String ARG_NUMBERS_CSV = "numbers_csv";
    private static final String ARG_IS_AUTO = "is_auto";

    private ExecutorService executorService;

    // UI 컴포넌트들
    private TextView tvNumbers;
    private TextView tvQualityScore;
    private TextView tvOddEvenRatio;
    private TextView tvRangeDistribution;
    private TextView tvConsecutiveNumbers;
    private TextView tvBalanceScore;
    private TextView tvFrequencyAnalysis;
    private TextView tvDisclaimer;

    public static NumberAnalysisDialog newInstance(GeneratedPickEntity pickEntity) {
        NumberAnalysisDialog dialog = new NumberAnalysisDialog();
        Bundle args = new Bundle();
        args.putString(ARG_NUMBERS_CSV, pickEntity.numbersCsv);
        args.putBoolean(ARG_IS_AUTO, pickEntity.isAutoGenerated());
        dialog.setArguments(args);
        return dialog;
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        executorService = Executors.newSingleThreadExecutor();
    }

    @NonNull
    @Override
    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
        View view = LayoutInflater.from(requireContext())
                .inflate(R.layout.dialog_number_analysis, null);

        initializeViews(view);

        if (getArguments() != null) {
            performAnalysis();
        }

        return new AlertDialog.Builder(requireContext())
                .setTitle(getString(R.string.number_analysis_title))
                .setView(view)
                .setPositiveButton(getString(R.string.close), null)
                .create();
    }

    private void initializeViews(View view) {
        tvNumbers = view.findViewById(R.id.tvNumbers);
        tvQualityScore = view.findViewById(R.id.tvQualityScore);
        tvOddEvenRatio = view.findViewById(R.id.tvOddEvenRatio);
        tvRangeDistribution = view.findViewById(R.id.tvRangeDistribution);
        tvConsecutiveNumbers = view.findViewById(R.id.tvConsecutiveNumbers);
        tvBalanceScore = view.findViewById(R.id.tvBalanceScore);
        tvFrequencyAnalysis = view.findViewById(R.id.tvFrequencyAnalysis);
        tvDisclaimer = view.findViewById(R.id.tvDisclaimer);
    }

    private void performAnalysis() {
        Bundle args = getArguments();
        if (args == null) return;

        String numbersCsv = args.getString(ARG_NUMBERS_CSV);
        boolean isAuto = args.getBoolean(ARG_IS_AUTO, true);

        executorService.execute(() -> {
            try {
                // 번호 파싱
                List<Integer> numbers = parseNumbers(numbersCsv);
                if (numbers.size() != 6) {
                    showError(getString(R.string.analysis_invalid_numbers));
                    return;
                }

                // CSV 데이터 로드
                List<DrawData> historicalData = loadHistoricalData();

                // 각종 분석 수행
                AnalysisResult result = analyzeNumbers(numbers, historicalData);

                // UI 업데이트
                requireActivity().runOnUiThread(() -> updateUI(numbers, result, isAuto));

            } catch (Exception e) {
                Log.e(TAG, "번호 분석 중 오류 발생", e);
                requireActivity().runOnUiThread(() ->
                        showError(getString(R.string.analysis_error, e.getMessage())));
            }
        });
    }

    private List<Integer> parseNumbers(String numbersCsv) {
        List<Integer> numbers = new ArrayList<>();
        if (numbersCsv != null) {
            String[] parts = numbersCsv.split(",");
            for (String part : parts) {
                try {
                    numbers.add(Integer.parseInt(part.trim()));
                } catch (NumberFormatException e) {
                    Log.w(TAG, "번호 파싱 실패: " + part);
                }
            }
        }
        Collections.sort(numbers);
        return numbers;
    }

    private List<DrawData> loadHistoricalData() throws IOException {
        List<DrawData> data = new ArrayList<>();

        try (InputStream is = requireContext().getAssets().open("draw_kor.csv");
             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {

            String line;
            boolean isFirstLine = true;

            while ((line = reader.readLine()) != null) {
                // 헤더 행 스킵
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                try {
                    DrawData drawData = parseDrawData(line);
                    if (drawData != null) {
                        data.add(drawData);
                    }
                } catch (Exception e) {
                    Log.w(TAG, "라인 파싱 실패: " + line, e);
                }
            }
        }

        Log.d(TAG, "로드된 회차 데이터: " + data.size() + "개");
        return data;
    }

    private DrawData parseDrawData(String line) {
        String[] parts = line.split(",");
        if (parts.length >= 10) { // year,drawNo,date,n1,n2,n3,n4,n5,n6,bonus = 10개
            try {
                DrawData data = new DrawData();
                // year,drawNo,date,n1,n2,n3,n4,n5,n6,bonus
                data.drawNo = Integer.parseInt(parts[1].trim());
                data.numbers = Arrays.asList(
                        Integer.parseInt(parts[3].trim()),  // n1
                        Integer.parseInt(parts[4].trim()),  // n2
                        Integer.parseInt(parts[5].trim()),  // n3
                        Integer.parseInt(parts[6].trim()),  // n4
                        Integer.parseInt(parts[7].trim()),  // n5
                        Integer.parseInt(parts[8].trim())   // n6
                );
                data.bonus = Integer.parseInt(parts[9].trim()); // bonus
                return data;
            } catch (NumberFormatException e) {
                Log.w(TAG, "숫자 파싱 실패: " + line);
            }
        }
        return null;
    }

    private AnalysisResult analyzeNumbers(List<Integer> numbers, List<DrawData> historicalData) {
        AnalysisResult result = new AnalysisResult();

        // 공통 분석기를 사용하여 기본 분석 수행
        LottoNumberAnalyzer.AnalysisResult commonAnalysis =
                LottoNumberAnalyzer.analyzeNumbers(numbers, null);

        if (commonAnalysis != null) {
            // 공통 분석 결과를 기존 구조에 맞게 변환
            result.oddEvenAnalysis = new OddEvenAnalysis(
                    commonAnalysis.oddEvenAnalysis.oddCount,
                    commonAnalysis.oddEvenAnalysis.evenCount
            );

            result.rangeAnalysis = new RangeAnalysis(
                    commonAnalysis.rangeAnalysis.rangeCounts
            );

            result.consecutiveAnalysis = new ConsecutiveAnalysis(
                    commonAnalysis.consecutiveAnalysis.consecutiveCount,
                    commonAnalysis.consecutiveAnalysis.consecutivePairs
            );

            // 통일된 품질 점수 사용
            result.balanceScore = commonAnalysis.qualityScore;
            result.qualityScore = commonAnalysis.qualityScore;
        } else {
            // 공통 분석기 실패 시 기본값 설정
            result.oddEvenAnalysis = new OddEvenAnalysis(0, 0);
            result.rangeAnalysis = new RangeAnalysis(new int[5]);
            result.consecutiveAnalysis = new ConsecutiveAnalysis(0, new ArrayList<>());
            result.balanceScore = 0;
            result.qualityScore = 0;
        }

        // 출현 빈도 분석 (기존 로직 유지 - 과거 데이터 필요)
        result.frequencyAnalysis = analyzeFrequency(numbers, historicalData);

        return result;
    }

    private FrequencyAnalysis analyzeFrequency(List<Integer> numbers, List<DrawData> historicalData) {
        Map<Integer, Integer> frequency = new HashMap<>();

        // 모든 번호의 출현 횟수 계산
        for (int i = 1; i <= 45; i++) {
            frequency.put(i, 0);
        }

        for (DrawData draw : historicalData) {
            for (int num : draw.numbers) {
                frequency.put(num, frequency.get(num) + 1);
            }
        }

        // 선택된 번호들의 빈도 분류
        int hotCount = 0;    // 상위 33% (자주 나오는 번호)
        int coldCount = 0;   // 하위 33% (드물게 나오는 번호)
        int normalCount = 0; // 중간 33% (보통 번호)

        List<Integer> allFreqs = new ArrayList<>(frequency.values());
        Collections.sort(allFreqs);

        int hotThreshold = allFreqs.get((int)(allFreqs.size() * 0.67));
        int coldThreshold = allFreqs.get((int)(allFreqs.size() * 0.33));

        for (int num : numbers) {
            Integer freq = frequency.get(num);
            if (freq != null) {
                if (freq >= hotThreshold) {
                    hotCount++;
                } else if (freq <= coldThreshold) {
                    coldCount++;
                } else {
                    normalCount++;
                }
            } else {
                // 빈도 데이터가 없는 경우 보통으로 분류
                normalCount++;
            }
        }

        return new FrequencyAnalysis(hotCount, normalCount, coldCount);
    }

    private void updateUI(List<Integer> numbers, AnalysisResult result, boolean isAuto) {
        // 번호 표시
        StringBuilder numberStr = new StringBuilder();
        for (int i = 0; i < numbers.size(); i++) {
            if (i > 0) numberStr.append(", ");
            numberStr.append(numbers.get(i));
        }

        String numbersText = isAuto ?
                getString(R.string.numbers_format_auto, numberStr.toString()) :
                getString(R.string.numbers_format_manual, numberStr.toString());
        tvNumbers.setText(numbersText);

        // 품질 점수 (이제 통일된 점수 사용)
        String qualityText;
        if (result.qualityScore >= 70) {
            qualityText = getString(R.string.quality_score_excellent, result.qualityScore);
        } else if (result.qualityScore >= 40) {
            qualityText = getString(R.string.quality_score_good, result.qualityScore);
        } else {
            qualityText = getString(R.string.quality_score_poor, result.qualityScore);
        }
        tvQualityScore.setText(qualityText);

        // 홀짝 비율
        tvOddEvenRatio.setText(getString(R.string.odd_even_format,
                result.oddEvenAnalysis.oddCount, result.oddEvenAnalysis.evenCount));

        // 구간 분포
        StringBuilder rangeStr = new StringBuilder();
        String[] rangeLabels = {
                getString(R.string.range_1_9),
                getString(R.string.range_10_18),
                getString(R.string.range_19_27),
                getString(R.string.range_28_36),
                getString(R.string.range_37_45)
        };

        for (int i = 0; i < result.rangeAnalysis.rangeCounts.length; i++) {
            if (i > 0) rangeStr.append(", ");
            rangeStr.append(getString(R.string.range_label_format,
                    rangeLabels[i], result.rangeAnalysis.rangeCounts[i]));
        }
        tvRangeDistribution.setText(getString(R.string.range_distribution_format, rangeStr.toString()));

        // 연속 번호
        if (result.consecutiveAnalysis.consecutiveCount == 0) {
            tvConsecutiveNumbers.setText(getString(R.string.consecutive_none));
        } else {
            tvConsecutiveNumbers.setText(getString(R.string.consecutive_found,
                    result.consecutiveAnalysis.consecutiveCount,
                    String.join(", ", result.consecutiveAnalysis.consecutivePairs)));
        }

        // 균형 점수 (품질 점수와 동일)
        tvBalanceScore.setText(getString(R.string.balance_score_format, result.balanceScore));

        // 출현 빈도
        tvFrequencyAnalysis.setText(getString(R.string.frequency_analysis_format,
                result.frequencyAnalysis.hotCount,
                result.frequencyAnalysis.normalCount,
                result.frequencyAnalysis.coldCount));

        // 면책 조항
        tvDisclaimer.setText(getString(R.string.analysis_disclaimer));
    }

    private void showError(String message) {
        requireActivity().runOnUiThread(() ->
                Toast.makeText(requireContext(), message, Toast.LENGTH_LONG).show());
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
        }
    }

    // ==================== 데이터 클래스들 ====================

    private static class DrawData {
        int drawNo;
        List<Integer> numbers;
        int bonus;
    }

    private static class AnalysisResult {
        OddEvenAnalysis oddEvenAnalysis;
        RangeAnalysis rangeAnalysis;
        ConsecutiveAnalysis consecutiveAnalysis;
        int balanceScore;
        FrequencyAnalysis frequencyAnalysis;
        int qualityScore;
    }

    private static class OddEvenAnalysis {
        int oddCount;
        int evenCount;

        OddEvenAnalysis(int odd, int even) {
            this.oddCount = odd;
            this.evenCount = even;
        }
    }

    private static class RangeAnalysis {
        int[] rangeCounts;

        RangeAnalysis(int[] counts) {
            this.rangeCounts = counts;
        }
    }

    private static class ConsecutiveAnalysis {
        int consecutiveCount;
        List<String> consecutivePairs;

        ConsecutiveAnalysis(int count, List<String> pairs) {
            this.consecutiveCount = count;
            this.consecutivePairs = pairs;
        }
    }

    private static class FrequencyAnalysis {
        int hotCount;     // 자주 나오는 번호
        int normalCount;  // 보통 번호
        int coldCount;    // 드문 번호

        FrequencyAnalysis(int hot, int normal, int cold) {
            this.hotCount = hot;
            this.normalCount = normal;
            this.coldCount = cold;
        }
    }
}